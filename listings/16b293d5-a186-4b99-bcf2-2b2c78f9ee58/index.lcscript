(function() {
// CONFIGURATION
const CHECK_INTERVAL = 1000;
const SURPASS_DELAY = 10;
const REVEAL_DELAY = 150;
const BLINK_COUNT = 1;
const GAP_THRESHOLD = 1;

// STATE
let isActive = false;
let surpassTimeout = null;
let currentSurpassEvent = null;
let previousValues = {};
let previousRank = {};
let loader = null;
let loaderText = null;
let overlay = null;
let lastTop50Id = null;

// STYLES
const style = document.createElement('style');
style.textContent = `
.surpass-dark-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.3); /* transparent black, no color, 0.3 opacity */
  z-index: 10000;
  pointer-events: none;
  transition: opacity 0.2s;
  user-select: none;
  overscroll-behavior: none !important;
}
.loader-stack-between-cards {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10001 !important;
  pointer-events: none;
  user-select: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  background: none;
  padding: 0;
  margin: 0;
}
.loader-gif-img {
  width: 54px;
  height: 54px;
  object-fit: contain;
  display: block;
  margin-bottom: 0px;
  pointer-events: none;
  user-select: none;
}
.update-message-between-cards {
  color: white;
  font-weight: 900;
  font-size: 2em;
  text-shadow: 0 0 5px rgba(0,0,0,0.6);
  background: none;
  border-radius: 12px;
  padding: 0;
  margin: 0;
  pointer-events: none;
  user-select: none;
  z-index: 10001 !important;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.update-message-between-cards .wait-main {
  font-size: 1em;
  font-weight: 900;
  margin-bottom: 2px;
}
.update-message-between-cards .small {
  font-size: 0.58em;
  font-weight: 700;
  opacity: 0.85;
  margin-top: 0;
  letter-spacing: 0.02em;
}
@keyframes card-blink {
  0%, 100% {
    transform: scale(1.05);
    box-shadow: transparent;
    background: rgb(34,33,40);
  }
  50% {
    transform: scale(1);
    box-shadow: none;
    background: rgb(34,33,40);
    opacity: 0.35;
  }
}
.card-updating {
  animation: card-blink 0.3s ${BLINK_COUNT};
  position: relative;
  z-index: 10;
  background: rgb(34,33,40) !important;
  color: white !important;
  font-weight: 900 !important;
  transition: background 0.15s, color 0.15s;
}
.card-hidden {
  visibility: hidden;
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.2s ease-out;
}
.pending-surpass {
  border-left: 4px solid gold;
}
`;
document.head.appendChild(style);

// GET CURRENT NUMERIC VALUE
function getCardValue(card) {
  const numText = card.querySelector('.num_text');
  if (!numText) return 0;
  return parseInt(numText.textContent) || 0;
}

// CHECK FOR SURPASSING OR TOP 50 CHANGE
function checkForSurpassingOrTop50() {
  if (isActive) return false;

  const cards = Array.from(document.querySelectorAll('.card'));
  const currentValues = {};
  let hasChange = false;

  // Get current values and check for changes
  cards.forEach(card => {
    const id = card.id;
    currentValues[id] = getCardValue(card);

    if (previousValues[id] !== currentValues[id]) {
      hasChange = true;
    }
  });

  // First run - initialize tracking
  if (Object.keys(previousValues).length === 0) {
    previousValues = currentValues;
    cards.forEach((card, index) => {
      previousRank[card.id] = index;
    });

    // Track initial top 50 card
    if (cards.length >= 50) {
      lastTop50Id = cards[49] && cards[49].id;
    }
    return false;
  }

  // Only proceed if values changed
  if (!hasChange) return false;

  // Get current ranking
  const currentRanking = cards
    .map(card => ({
      id: card.id,
      value: currentValues[card.id],
      element: card
    }))
    .sort((a, b) => b.value - a.value);

  // Check for position changes
  let surpassEvent = null;
  currentRanking.forEach((card, newIndex) => {
    const oldIndex = previousRank[card.id];
    if (oldIndex > newIndex &&
      (currentValues[card.id] - currentValues[currentRanking[newIndex + 1]?.id] >= GAP_THRESHOLD)) {
      surpassEvent = {
        cards: cards,
        timestamp: Date.now()
      };
    }
  });

  // Check for top 50 change
  let top50Changed = false;
  if (cards.length >= 50) {
    const top50Card = currentRanking[49];
    if (top50Card && top50Card.id !== lastTop50Id) {
      top50Changed = true;
      lastTop50Id = top50Card.id;
    }
  }

  // Update previous state
  previousValues = currentValues;
  currentRanking.forEach((card, index) => {
    previousRank[card.id] = index;
  });

  // Trigger on either surpass or top 50 change
  if (surpassEvent) return surpassEvent;
  if (top50Changed) return { cards: cards, timestamp: Date.now(), top50: true };
  return false;
}

// POSITION BETWEEN CARDS
function positionBetweenCards() {
  const cards = document.querySelectorAll('.card');
  if (cards.length < 27) return;

  // Loader+text stack: centered between 25th and 26th card (index 24 and 25 for loader, 25 and 26 for text)
  const card24 = cards[23];
  const card25 = cards[24];
  const card26 = cards[25];

  // Get bounding rects
  const rect24 = card24.getBoundingClientRect();
  const rect25 = card25.getBoundingClientRect();
  const rect26 = card26.getBoundingClientRect();

  // Vertical position: stack is between card25 and card26 (so: (card25.bottom + card26.top)/2)
  const stackTop = (rect25.bottom + rect26.top) / 2 + window.scrollY;

  if (loader && loader.parentElement) {
    loader.parentElement.style.top = `${stackTop - 34}px`; // a bit above
  }
}

// ANIMATION SEQUENCE
function executeUpdate(cards) {
  isActive = true;

  // Add dark overlay if not present
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.className = 'surpass-dark-overlay';
    overlay.style.opacity = '1';
    document.body.appendChild(overlay);
  } else {
    overlay.style.opacity = '1';
    overlay.style.display = '';
  }
  overlay.style.zIndex = 10000;

  // Remove previous loader stack if any
  if (loader && loader.parentElement) loader.parentElement.remove();
  loader = null;

  // Make a flex column stack for loader and text
  const loaderStack = document.createElement('div');
  loaderStack.className = 'loader-stack-between-cards';
  loaderStack.style.zIndex = 10001;

  // Loader (custom gif)
  loader = document.createElement('img');
  loader.className = 'loader-gif-img';
  loader.src = 'https://i.imgur.com/btGcXS4.gif';
  loader.alt = 'Loading...';
  loader.style.opacity = '1';
  loader.style.zIndex = 10001;
  loader.style.pointerEvents = 'none';
  loader.style.userSelect = 'none';

  // Loader text (Please wait... on top, then small)
  loaderText = document.createElement('div');
  loaderText.className = 'update-message-between-cards';
  loaderText.style.opacity = '1';
  loaderText.style.zIndex = 10001;
  loaderText.style.pointerEvents = 'none';
  loaderText.style.userSelect = 'none';
  loaderText.innerHTML = `
    <span class="wait-main">Please wait...</span>
    <span class="small">We are checking for changed information.</span>
  `;

  loaderStack.appendChild(loader);
  loaderStack.appendChild(loaderText);
  document.body.appendChild(loaderStack);

  // Position loader stack
  positionBetweenCards();
  window.addEventListener('resize', positionBetweenCards);
  window.addEventListener('scroll', positionBetweenCards);

  // Hide all cards
  cards.forEach(card => {
    card.classList.add('card-hidden');
  });

  // Prevent double refresh: clear any old timeouts
  if (surpassTimeout) {
    clearTimeout(surpassTimeout);
    surpassTimeout = null;
  }

  // Animation sequence
  setTimeout(() => {
    // Reveal cards one by one in their original order
    cards.forEach((card, index) => {
      setTimeout(() => {
        card.classList.remove('card-hidden');
        card.classList.add('card-updating');

        // Remove animation class after it completes
        setTimeout(() => {
          card.classList.remove('card-updating');
          // Remove message and reset state after last card
          if (index === cards.length - 1) {
            setTimeout(() => {
              if (loaderStack) loaderStack.remove();
              loader = null;
              loaderText = null;
              if (overlay) {
                overlay.style.opacity = '0';
                overlay.style.display = 'none';
              }
              window.removeEventListener('resize', positionBetweenCards);
              window.removeEventListener('scroll', positionBetweenCards);
              isActive = false;
            }, 300);
          }
        }, BLINK_COUNT * 300);
      }, index * REVEAL_DELAY);
    });
  }, 300);
}

// MONITORING SYSTEM
function startMonitoring() {
  let lastSurpassTimestamp = 0;
  setInterval(() => {
    if (isActive) return;

    const newSurpassEvent = checkForSurpassingOrTop50();

    // Prevent triggering twice in a row for same event
    if (newSurpassEvent && (!lastSurpassTimestamp || (Date.now() - lastSurpassTimestamp > 1000))) {
      lastSurpassTimestamp = Date.now();

      // Clear any pending timeout
      if (surpassTimeout) {
        clearTimeout(surpassTimeout);
        surpassTimeout = null;
      }

      // Store the new event
      currentSurpassEvent = newSurpassEvent;

      // Mark cards as pending
      currentSurpassEvent.cards.forEach(card => {
        card.classList.add('pending-surpass');
      });

      // Set timeout for the actual animation
      surpassTimeout = setTimeout(() => {
        if (currentSurpassEvent) {
          currentSurpassEvent.cards.forEach(card => {
            card.classList.remove('pending-surpass');
          });
          executeUpdate(currentSurpassEvent.cards);
          currentSurpassEvent = null;
        }
      }, SURPASS_DELAY);
    }
  }, CHECK_INTERVAL);
}

// INITIALIZE
console.log('hi there');
startMonitoring();
})();
